---
# ========================================================================
# FINAL AUTOMATION-LEVEL LOGGING - REUSABLE ROLE
# ========================================================================
# This role writes ONE final record to AUTOMATION_LOGS after automation completes
# Usage: Include this role in the 'always' section of your playbook's main block
# 
# CRITICAL LOGGING WITH RETRY LOGIC:
#   - Retries: 3 attempts with 5-second delay between attempts
#   - Failure: Returns ARC_8000 (LOGGING_SYSTEM_FAILURE) if all retries fail
#   - This ensures data integrity - logging failures are treated as critical
#
# Required variables:
#   - automation_name: Name of the automation
#   - return_code: Automation return code (e.g., ARC_0000)
#   - automation_start_time: IST timestamp when automation started (YYYY-MM-DD HH:MM:SS.mmm)
#   - snowflake_password: Snowflake connection password (must be provided via playbook)
# 
# Optional variables (defaults provided in defaults/main.yml):
#   - snowflake_environment: Environment selector (prod/dev, default: dev)
#   - snowflake_account, snowflake_user, snowflake_database, 
#     snowflake_warehouse, snowflake_schema, snowflake_role
#   - job_id: Unique job identifier (auto-detected from AAP or generated)
#   - ci_name: Configuration Item name (default: automation_name)
#   - additional_context: Extra information to append to error message
#   - ai_assisted: Whether AI was used (default: false)
#   - ai_tokens_used: Number of AI tokens consumed (default: 0)
#   - ai_human_approved: Whether AI output was human-approved (default: false)
#   - ai_approved_by: Who approved the AI output (default: "N/A")
# 
# Environment toggling:
#   - Default (dev): ansible-playbook playbook.yaml
#   - Production: ansible-playbook playbook.yaml -e snowflake_environment=prod
# 
# TIMEZONE STRATEGY:
#   All timestamps (STARTED_AT, COMPLETED_AT) are stored in IST (UTC+5:30)
#   - Generated by: include_tasks: timestamp_ist.yml
#   - Format: YYYY-MM-DD HH:MM:SS.mmm
#   - No session TZ dependency - consistent across all environments
# ========================================================================

- name: "Detect execution environment and set job_id"
  set_fact:
    detected_job_id: |
      {%- if job_id is defined and job_id | length > 0 -%}
        {{ job_id }}
      {%- elif job_id_override is defined and job_id_override | length > 0 -%}
        {{ job_id_override }}
      {%- elif lookup('env', 'AWX_JOB_ID') | length > 0 -%}
        AAP_{{ lookup('env', 'AWX_JOB_ID') }}
      {%- elif lookup('env', 'TOWER_JOB_ID') | length > 0 -%}
        TOWER_{{ lookup('env', 'TOWER_JOB_ID') }}
      {%- else -%}
        CLI_{{ ansible_date_time.epoch }}
      {%- endif -%}
  ignore_errors: true  # Never fail in always block

- name: "Display execution context"
  debug:
    msg:
      - "Job ID: {{ detected_job_id | trim }}"
      - "CI: {{ ci_name }}"
  when: ansible_verbosity >= 1
  ignore_errors: true  # Never fail in always block

- name: "Query RETURN_CODES table for error details"
  community.snowflake.snowflake_query:
    snowflake_account: "{{ snowflake_account }}"
    snowflake_user: "{{ snowflake_user }}"
    snowflake_password: "{{ snowflake_password }}"
    snowflake_database: "{{ snowflake_database }}"
    snowflake_warehouse: "{{ snowflake_warehouse }}"
    snowflake_schema: "{{ snowflake_schema }}"
    query: |
      SELECT 
        RETURN_CODE,
        ERROR_TYPE,
        ERROR_CATEGORY,
        SEVERITY,
        ERROR_MESSAGE,
        ERROR_DESCRIPTION,
        RESOLUTION_HINT
      FROM RETURN_CODES
      WHERE RETURN_CODE = :code
    parameters:
      code: "{{ return_code }}"
    output_format: json
    timeout: 30
  register: return_code_details
  ignore_errors: true  # Never fail in always block

- name: "Extract error details from RETURN_CODES query result"
  set_fact:
    error_type: "{{ return_code_details.rows[0].ERROR_TYPE if return_code_details.rows is defined and return_code_details.rows | length > 0 else 'UNKNOWN' }}"
    error_message: "{{ return_code_details.rows[0].ERROR_MESSAGE if return_code_details.rows is defined and return_code_details.rows | length > 0 else 'Unknown error' }}"
    return_code_severity: "{{ return_code_details.rows[0].SEVERITY if return_code_details.rows is defined and return_code_details.rows | length > 0 else 'unknown' }}"
    resolution_hint: "{{ return_code_details.rows[0].RESOLUTION_HINT if return_code_details.rows is defined and return_code_details.rows | length > 0 else 'Check logs' }}"
  when: return_code_details is succeeded
  ignore_errors: true  # Never fail in always block

- name: "Warn if RETURN_CODES query failed"
  debug:
    msg:
      - "⚠️  WARNING: Failed to query RETURN_CODES table"
      - "Error: {{ return_code_details.msg | default('Unknown error') }}"
      - "Using fallback values for logging"
  when: return_code_details is failed

- name: "Prepare final error message with additional context"
  set_fact:
    final_error_message: "{{ error_message | default('Unknown error') }}{{ ' | ' + additional_context if additional_context is defined and additional_context | length > 0 else '' }}"
  ignore_errors: true  # Never fail in always block

- name: "Set AI approval defaults when AI is not used"
  set_fact:
    final_ai_human_approved: "{{ false if not (ai_assisted | default(false)) else (ai_human_approved | default(false)) }}"
    final_ai_approved_by: "{{ 'N/A' if not (ai_assisted | default(false)) else (ai_approved_by | default('N/A')) }}"
  ignore_errors: true  # Never fail in always block

- name: "Ensure automation_name is defined and not empty"
  set_fact:
    final_automation_name: "{{ automation_name if automation_name is defined and automation_name | length > 0 else 'UNKNOWN_AUTOMATION' }}"
  ignore_errors: true  # Never fail in always block

- name: "Debug automation_name value before insert"
  debug:
    msg:
      - "automation_name variable: {{ automation_name | default('UNDEFINED') }}"
      - "final_automation_name: {{ final_automation_name }}"
      - "ci_name: {{ ci_name | default('UNDEFINED') }}"
  when: ansible_verbosity >= 1
  ignore_errors: true  # Never fail in always block

- name: "Capture completion timestamp in IST"
  include_tasks: timestamp_ist.yml
  ignore_errors: true  # Never fail in always block

- name: "Set Automation Completion Time (IST)"
  set_fact:
    automation_completed_time: "{{ ist_timestamp }}"
  when: ist_timestamp is defined
  ignore_errors: true  # Never fail in always block

- name: "Fallback completion time if IST generation fails"
  set_fact:
    automation_completed_time: "{{ automation_start_time }}"
  when: ist_timestamp is not defined
  ignore_errors: true  # Never fail in always block

- name: "Verify timestamp consistency"
  debug:
    msg:
      - "========================================"
      - "  TIMESTAMP VALIDATION"
      - "========================================"
      - "  Started (IST):   {{ automation_start_time }}"
      - "  Completed (IST): {{ automation_completed_time }}"
      - "  Timezone: IST (UTC+5:30) - Controlled"
      - "========================================"
  ignore_errors: true  # Never fail in always block

# ========================================================================
# CRITICAL LOGGING OPERATION - STRICT ERROR HANDLING WITH RETRY LOGIC
# ========================================================================
# Failure to write logs is treated as a CRITICAL system failure (ARC_8000)
# Retries: 3 attempts with exponential backoff before failing
# ========================================================================

- name: "Set logging retry configuration"
  set_fact:
    logging_max_retries: 3
    logging_retry_delay: 5
  ignore_errors: true

- name: "Critical Logging Operation - Write to AUTOMATION_LOGS"
  block:
    - name: "Write final automation log to AUTOMATION_LOGS (with retry logic)"
      community.snowflake.snowflake_query:
        snowflake_account: "{{ snowflake_account }}"
        snowflake_user: "{{ snowflake_user }}"
        snowflake_password: "{{ snowflake_password }}"
        snowflake_database: "{{ snowflake_database }}"
        snowflake_warehouse: "{{ snowflake_warehouse }}"
        snowflake_schema: "{{ snowflake_schema }}"
        query: |
          INSERT INTO AUTOMATION_LOGS (
            AUTOMATION_NAME,
            JOB_ID,
            STATUS,
            RETURN_CODE,
            ERROR_TYPE,
            ERROR_MESSAGE,
            STARTED_AT,
            COMPLETED_AT,
            AI_ASSISTED,
            AI_TOKENS_USED,
            AI_HUMAN_APPROVED,
            AI_APPROVED_BY,
            CI
          ) VALUES (
            :automation_name,
            :job_id,
            :status,
            :return_code,
            :error_type,
            :error_message,
            :started_at,
            :completed_at,
            :ai_assisted,
            :ai_tokens,
            :ai_human_approved,
            :ai_approved_by,
            :ci
          )
        parameters:
          automation_name: "{{ final_automation_name }}"
          job_id: "{{ detected_job_id | trim }}"
          status: "{{ 'SUCCESS' if return_code == 'ARC_0000' else ('PARTIAL' if return_code == 'ARC_0002' else 'FAILED') }}"
          return_code: "{{ return_code }}"
          error_type: "{{ error_type | default('UNKNOWN') }}"
          error_message: "{{ final_error_message }}"
          started_at: "{{ automation_start_time }}"
          completed_at: "{{ automation_completed_time }}"
          ai_assisted: "{{ ai_assisted | default(false) }}"
          ai_tokens: "{{ ai_tokens_used | default(0) }}"
          ai_human_approved: "{{ final_ai_human_approved }}"
          ai_approved_by: "{{ final_ai_approved_by }}"
          ci: "{{ ci_name }}"
        output_format: json
        timeout: 30
      register: log_write_result
      retries: "{{ logging_max_retries | int }}"
      delay: "{{ logging_retry_delay | int }}"
      until: log_write_result is succeeded
    
    - name: "Display retry attempts (if any)"
      debug:
        msg:
          - "Logging operation succeeded after {{ log_write_result.attempts | default(1) }} attempt(s)"
      when: 
        - log_write_result.attempts is defined
        - log_write_result.attempts | int > 1

    - name: "Display logging success"
      debug:
        msg:
          - "✅ Automation log successfully written to Snowflake AUTOMATION_LOGS"
          - "Automation Name: {{ final_automation_name }}"
          - "Job ID: {{ detected_job_id | trim }}"
          - "Return Code: {{ return_code }}"
          - "Attempts: {{ log_write_result.attempts | default(1) }}"
          - "Started:   {{ automation_start_time }}"
          - "Completed: {{ automation_completed_time }}"

  rescue:
    - name: "Set CRITICAL logging failure return code"
      set_fact:
        return_code: "ARC_8000"
        logging_failure_message: "{{ log_write_result.msg | default(ansible_failed_result.msg | default('Unknown logging error')) }}"
        logging_attempts: "{{ log_write_result.attempts | default(logging_max_retries) }}"

    - name: "Display CRITICAL logging failure"
      debug:
        msg:
          - "❌ ═══════════════════════════════════════════════════════"
          - "❌ CRITICAL ERROR: AUTOMATION LOGGING FAILED"
          - "❌ ═══════════════════════════════════════════════════════"
          - "Return Code: ARC_8000 (LOGGING_SYSTEM_FAILURE)"
          - "Table: AUTOMATION_LOGS"
          - "Automation Name: {{ final_automation_name }}"
          - "Job ID: {{ detected_job_id | trim }}"
          - "Original Return Code: {{ return_code }}"
          - "Retry Attempts: {{ logging_attempts }}/{{ logging_max_retries }}"
          - "Retry Delay: {{ logging_retry_delay }}s between attempts"
          - "Error: {{ logging_failure_message }}"
          - ""
          - "❌ CRITICAL: Unable to persist automation execution record"
          - "❌ All {{ logging_max_retries }} retry attempts exhausted"
          - "❌ This indicates a PERSISTENT SYSTEM-LEVEL failure"
          - ""
          - "Immediate Actions Required:"
          - "  1. Verify AUTOMATION_LOGS table exists and is accessible"
          - "  2. Check Snowflake credentials and connection"
          - "  3. Verify user permissions for INSERT operations"
          - "  4. Check table schema matches the INSERT statement"
          - "  5. Verify network connectivity to Snowflake"
          - "  6. Check Snowflake warehouse state (suspended/running)"
          - "  7. Review Snowflake query history for detailed error"
          - "  8. Check for resource limit or quota issues"
          - ""
          - "Impact:"
          - "  - Automation execution data NOT persisted"
          - "  - Metrics and audit trail incomplete"
          - "  - Error handling notifications may not trigger"
          - "❌ ═══════════════════════════════════════════════════════"

    - name: "Fail automation due to critical logging failure"
      fail:
        msg: "CRITICAL: Automation logging failed with return code ARC_8000 after {{ logging_max_retries }} retry attempts. Unable to persist execution record to AUTOMATION_LOGS table. Error: {{ logging_failure_message }}"

# ========================================================================
# ERROR HANDLING - Automatic Failure Notifications
# ========================================================================
# Query AUTOMATION_REGISTRY for error handling configuration
# Only triggered when automation fails (STATUS != SUCCESS)
# ========================================================================

- name: "Check if error handling is required"
  set_fact:
    requires_error_handling: "{{ return_code != 'ARC_0000' }}"
  ignore_errors: true

- name: "Query AUTOMATION_REGISTRY for error handling configuration"
  community.snowflake.snowflake_query:
    snowflake_account: "{{ snowflake_account }}"
    snowflake_user: "{{ snowflake_user }}"
    snowflake_password: "{{ snowflake_password }}"
    snowflake_database: "{{ snowflake_database }}"
    snowflake_warehouse: "{{ snowflake_warehouse }}"
    snowflake_schema: "{{ snowflake_schema }}"
    query: |
      SELECT 
        ERROR_HANDLING_ENABLED,
        ERROR_HANDLING_MATRIX,
        APPROVED_ERROR_HANDLERS,
        NOTIFICATION_CHANNELS,
        OWNER_EMAIL,
        OWNER_NAME,
        DISPLAY_NAME
      FROM AUTOMATION_REGISTRY
      WHERE AUTOMATION_NAME = :automation_name
    parameters:
      automation_name: "{{ final_automation_name }}"
    output_format: json
    timeout: 30
  register: error_handling_config
  when: requires_error_handling | bool
  ignore_errors: true

- name: "Process error handling configuration"
  include_tasks: error_handling_dispatch.yml
  when:
    - requires_error_handling | bool
    - error_handling_config is succeeded
    - error_handling_config.rows is defined
    - error_handling_config.rows | length > 0
    - error_handling_config.rows[0].ERROR_HANDLING_ENABLED | default(false) | bool
  ignore_errors: true
